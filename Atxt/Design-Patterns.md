## 设计模式



### 软件设计模式的概念

软件设计模式（Software Design Pattern），又称**设计模式**，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。**它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。**也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了**提高代码的可重用性、代码的可读性和代码的可靠性**。



### 设计模式的意义

设计模式的本质是面向对象设计原则的**实际运用**，是**对类的封装性、继承性和多态性**以及类的**关联关系**和**组合关系**的充分理解。正确使用设计模式具有以下优点：

- 可以提高程序员的**思维能力**、**编程能力**和**设计能力**。
- 使程序设计**更加标准化**、**代码编制更加工程化**，使**软件开发效率大大提高**，从而缩短软件的开发周期。
- 使设计的代码**可重用性高**、**可读性强**、**可靠性高**、**灵活性好**、**可维护性强**。

### 设计模式的四个基本要素

#### 	1. 模式名称

​	模式的名字通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（Pattern Name）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。

#### 	2. 问题

​	问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。

#### 	3. 解决方案

​	模式问题的解决方案（Solution）包括**设计的组成成分**、**它们之间的相互关系**及**各自的职责和协作方式**。因为模式就像一个模板，可应用于多种不同场合，所以**解决方案并不描述一个特定而具体的设计或实现**，而是提供设计**问题的抽象描述**和怎样用一个具有**一般意义的元素组合**（类或对象的 组合）来解决这个问题。

#### 	4. 效果

​	描述了模式的**应用效果**以及使用该模式应该权衡的问题，即**模式的优缺点**。主要是**对时间和空间的衡量**，以及该模式对系统的**灵活性**、**扩充性**、**可移植性**的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。



### 设计模式的分类

1.**根据目的分类**；

2.**根据作用范围分类**；

### 根据目的来分类：

**创建型模式**：描述如何创建对象；

​	单例、原型、工厂方法、抽象工厂、建造者。

**结构模式**：用于描述如何将类或对象按某种布局组成更大的结构；

​	代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。

**行为模式**：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。	

​	模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。

### 根据作用范围来分：

**类模式**：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了；

​	工厂方法、（类）适配器、模板方法、解释器属于该模式。

**对象模式**：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。

![image-20220401141815821](https://raw.githubusercontent.com/qingjiusanliangsan/typora/main/img/20220401141815.png)

### GoF的23种设计模式的功能

1. **单例**（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
2. **原型**（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
3. **工厂方法**（Factory Method）模式：定义一个用于**创建产品**的接口，由子类决定生产什么产品。
4. **抽象工厂**（AbstractFactory）模式：提供一个**创建产品族**的接口，其每个子类可以生产一系列相关的产品。
5. **建造者**（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
6. **代理**（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
7. **适配器**（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
8. **桥接**（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
9. **装饰**（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
10. **外观**（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
11. **享元**（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
12. **组合**（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
13. **模板方法**（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
14. **策略**（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
15. **命令**（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
16. **职责链**（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
17. **状态**（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
18. **观察者**（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
19. **中介者**（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
20. **迭代器**（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
21. **访问者**（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
22. **备忘录**（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
23. **解释器**（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。



### 优秀的软件架构

1.代码复用：

​	在最底层，可以复用类、类库、容器，也许还有一些类的“团体（例如容器和迭代器）；

​	中间层次：设计模式所处的位置；

​	框架位于最高层。

2.扩展性： 不变的只有改变。



### 软件设计模式7原则

![image-20220401151105262](https://raw.githubusercontent.com/qingjiusanliangsan/typora/main/img/20220401151105.png)

**目的都是让程序低耦合，高复用，高内聚，易扩展，易维护。**

这些原则的目的只有一个：**降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。**



### 单例（Singleton）模式

指一个类只有一个实例，且该类能自行创建这个实例的一种模式。

**单例模式有 3 个特点：**

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点。

**单例模式的优点：**

- 单例模式可以保证内存里只有一个实例，减少了内存的开销。

- 可以避免对资源的多重占用。

- 单例模式设置全局访问点，可以优化和共享资源的访问。

  

  **单例模式的缺点：**

- 单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。
- 在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。
- 单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。

**第 1 种：懒汉式单例**

该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。

```java
public class LazySingleton {
    private static volatile LazySingleton instance = null;    //保证 instance 在所有线程中同步

    private LazySingleton() {
    }    //private 避免类在外部被实例化

    public static synchronized LazySingleton getInstance() {
        //getInstance 方法前加同步
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

第二种 饿汉式单例

```java
public class HungrySingleton {
    private static final HungrySingleton instance = new HungrySingleton();

    private HungrySingleton() {
    }

    public static HungrySingleton getInstance() {
        return instance;
    }
}
```





### 观察者（Observer）模式：

指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。



观察者模式是一种对象行为型模式，其**主要优点如下**：

1. 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。
2. 目标与观察者之间建立了一套触发机制。



**缺点如下**：

1. 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
2. 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。



观察者模式的主要角色如下：

1. **抽象主题**（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
2. **具体主题**（Concrete Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
3. **抽象观察者**（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
4. **具体观察者**（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。



```java
import java.util.*;

public class ObserverPattern {
    public static void main(String[] args) {
        Subject subject = new ConcreteSubject();
        Observer obs1 = new ConcreteObserver1();
        Observer obs2 = new ConcreteObserver2();
        subject.add(obs1);
        subject.add(obs2);
        subject.notifyObserver();
    }
}

//抽象目标
abstract class Subject {
    protected List<Observer> observers = new ArrayList<Observer>();
    //增加观察者方法
    public void add(Observer observer) {
        observers.add(observer);
    }
    //删除观察者方法
    public void remove(Observer observer) {
        observers.remove(observer);
    }
    public abstract void notifyObserver(); //通知观察者方法
}

//具体目标
class ConcreteSubject extends Subject {
    public void notifyObserver() {
        System.out.println("具体目标发生改变...");
        System.out.println("--------------");

        for (Object obs : observers) {
            ((Observer) obs).response();
        }
    }
}

//抽象观察者
interface Observer {
    void response(); //反应
}
//具体观察者1
class ConcreteObserver1 implements Observer {
    public void response() {
        System.out.println("具体观察者1作出反应！");
    }
}
//具体观察者1
class ConcreteObserver2 implements Observer {
    public void response() {
        System.out.println("具体观察者2作出反应！");
    }
}
```

