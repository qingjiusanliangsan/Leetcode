
# MySQL笔记

### Mysql索引失效的情况：

[十五个索引失效的情况](https://mp.weixin.qq.com/s/iBPO4Y_Q5ANSZ9iETAdMvA)

1.全值匹配都会用到索引；

2.最佳左前缀法则：多列的联合索引，要遵守最左前缀法则，即查询从索引的最左前列开始并且不跳过索引中的列。**最佳左前缀法则：带头大哥不能死、中间兄弟不能断。**

​		从最左开始，建立的第一个索引不能丢失；

​		中间的字段不能断；

​		**范围列可以用到索引，但是范围列后面的列无法用到索引**：存储引擎不能**使用索引中范围条件右边的列**，即如果出现了范围查询，则此范围查询右边的索引会失效；

3.不能在索引字段上做任何操作，如计算、函数、sub、自动或手动的类型转换等；

4.尽量使用覆盖查询，减少使用select *;

5.使用不等于（!= 、<>）的时候会无法使用索引，导致全局扫描；

6.is null, is not null也无法使用索引；复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。

7.like的模糊查询以%开头会导致索引失效；但是如果想让**以‘%’开头仍然使用索引**，则需要使用覆盖索引，即只查询带索引字段的列；

8.字符串不加单引号会使索引失效；

9.用or进行连接会使索引失效；**查询条件使用or关键字，其中一个字段没有创建索引，则会导致整个查询语句索引失效；or两边为“>”和“<”范围查询时，索引失效**。

10.如果mysql估计使用全表扫描要比使用索引快,则不使用索引。

### mysql 查询优化器

当按照索引中所有列进行精确匹配**（“=” 或 “IN”）**时，索引可以被用到，并且 type 为 const。理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，**所以 MySQL 不存在 where 子句的顺序问题而造成索引失效。**



### 索引的选择性：

索引的数量和数据表总数的比值，最大为1，越大代表索引越好。

### 索引列长度过长时：

1.可以使用模拟哈希索引;

2.使用前缀索引，即以此列的前缀字符串作为索引，但是此时希望前缀索引的选择性越大越好。

3.前缀的长度和索引的选择性之间要有一个平衡，既不能太长又要有选择性。

### 前缀索引：

优点:索引更小、更快；

缺点：mysql无法使用前缀索引做order by和group by；

### 后缀索引：

后缀索引也同样有用途，比如用来给电子邮件地址建后缀索引；

虽然Mysql不支持后缀索引，但可以对字符串反转之后建前缀索引来达到建立后缀索引的目标。

### 索引合并：

1.当出现多个单独索引做相交操作（AND）时，最好为这些索引做一个多列索引；

2.当出现多个单独索引做联合操作（OR）时，会浪费大量的CPU和内存资源；

3.优化器不会把这些资源计算在查询成本中，优化器只关心随机页面的读取。

### 索引的顺序：

1.多列索引的顺序从左到右排序，先按照左边第一列排序与，然后按照依次往右的列排序。

### 索引顺序的排列：

1.不用考虑排序和分组时，将**选择性**最高的列放到最左边。

2.但是场景不同，选择也不尽相同,有时候需要考虑最常用到的查询语句来进行优化。

3.平均情况的性能也能代表特殊情况下的性能，特殊情况可能回摧毁整个应用的性能。

### 聚簇索引：

1.**聚簇索引**时一种数据存储方式，并不是一个单独的索引类型，通常代表索引和数据行放在一块存储的索引方式。

2.因为无法同时把数据行和索引放在不同的地方，所以一个表只能右一个聚簇索引；

3.可以使用覆盖索引模拟多个聚簇索引的情况。

4.索引是由存储引擎负责实现的。

### 聚集索引的选择：

1.有些数据库服务器支持选择作为聚簇索引的列，但是Mysql暂时不支持。

### InnoDB的聚簇索引构建：

1.InnoDB引擎通过主键聚集数据；

2.若没有主键，则选取一个**唯一的非空索引**代替；

3.若没有唯一的非空索引，则**隐私定义一个主键**来作为聚簇索引。



### 聚簇索引的优缺点：

#### 优点：

1.相关数据保存在一起，存储密集，访问磁盘的数量变小，可以减少IO消耗；

2.数据访问更快，索引和数据在一块；

3.使用覆盖索引可以直接使用叶结点中的主键值。

#### 缺点：

1.非主键的插入会变慢；

2.每一次更新都可能导致移动数据；

3.会导致也分裂；

4.导致全表扫描变慢；

5.二级索引变大；二级索引需要两次查询，第一次查询到主键索引，第二次根据主键索引来进行查询实际的数据。

### 二级索引

1.二级索引的叶子结点的数据时行指针，保存的是指向主键指针的位置，而不是行的物理位置。

2.二级索引查找：首先根据二级索引的叶子节点找到对应的主键值；根据主键值查找对应的行。



### InnoDB的聚簇索引：

1.每一个叶子节点都包括了**主键值**、**事务ID**、用于事务的**MVCC**和**回滚指针**以及**其他的剩余列**。

2.InnoDB的二级索引存储的是主键值，而不是行指针，这样数据更新时，二级索引不需要改变，只需一级索引改变。虽然主键值占用空间更大，但是好处也很大，减少了更多的操作。

![image-20220401142319777](https://raw.githubusercontent.com/qingjiusanliangsan/typora/main/img/20220401142319.png)



### 覆盖索引

1.如果一个索引包含所有需要查询的字段的值，我们就称整个索引为**覆盖索引**。

2.覆盖索引只需要扫描，不需要回表，速度很快；

3.覆盖索引必须要存储索引列的值。



### Mysql的覆盖索引

1.mysql不能在索引中执行Like操作。

2.MySQL能在索引中做最左前缀匹配的LIke查询。



### MySQL使用索引对结果做排序

1.只有当列顺序和ORDER BY字句的顺序完全一致，并且所有列的排序方向（正序和倒序）都一样时，MySQL才可以使用索引来对结果做排序。

2.若查询关联了多张表，只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。

3.使用索引做排序的一个最重要的用法是当**查询同时有ORDER BY和LIMIT子句**的时候。



### MyISAM压缩（前缀压缩）索引

1.以第一个值为基准，将其他值和第一个比较。如“perform performance”  -> "7 7,ance"

2.空间变小，速度变慢；



### 冗余和重复索引

1.MySQL的每个索引都要单独维护；

重复索引：A，A

冗余索引：（A，B）,A



### InnoDB的索引和锁：

1.InnoDB在二级索引上使用共享锁，但是访问主键索引需要排他锁。

2.这个方式消除了使用覆盖索引的可能性；并且使得select for update 比 lock in share mode慢很多。

3.尽可能的将需要做范围查询的列放到索引的后面，以便优化器能使用尽可能多的索引列。



### MySQL的锁

分为**全局锁**、**表级锁**和**行锁**；

### MySQL全局锁

1.全局锁就是对整个数据库加锁；

2.全局读锁：Flush tables with read lock(FTWRL)，整个数据库处于只读状态。

3.加了全局读锁之后，关于数据库的更新会被堵塞：**数据更新语句**(数据的增删改)、**数据定义语句**(建表、修改表结构等)和**更新类事务**的提交语句。

### 全局锁的典型使用场景：

做全库的逻辑备份：也就是把整个库的每个表都select出来存成文本。

**全库逻辑备份**：官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。

### 逻辑备份时锁的选择：

1.若是支持single-transaction级别的隔离，可以使用事务来进行，此时不影响数据库更新；

2.若有点表使用了不支持事务的引擎，则只能使用FTWTL的锁，此时不能进行数据库的更新操作。

### FTWRL 和 readonly的选择：

1.推荐使用FTWRL;

2.readonly会用来判断是主库还是从库，影响较大；

3.遇到异常时，FTWRL会自动释放锁，但是readonly不会释放。

### MySQL的表级锁：

1.表锁；

2.元数据锁（meta data lock,MDL）;

### 表锁的语法：

加锁：lock tables ... read/write;     释放： unlock tables;或者在客户端断开的时候释放。

表锁一般是**在数据库引擎不支持行锁**的时候才会被用到的。

### 表锁的范围限制：

lock tables**不但会限制其他线程的读写**，还会限制**本线程只能操作加锁的表**；

### MDL锁（metadata lock）

1.MDL不需要显式使用，在访问一个表的时候**会被自动加上**;

2.MDL的作用是，**保证读写的正确性**。

### MDL读锁 & MDL写锁

1.当对一个表做**增删改查**操作的时候，加**MDL读锁**；

2.当要对**表做结构变更操作**的时候，加**MDL写锁**。
3.**读锁之间不互斥**，因此你可以有多个线程同时对一张表增删改查。
4.**读写锁**之间、**写锁之间**是互斥的，用来保证变更表结构操作的安全性。

5.因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

### MDL锁的释放：

事务中的MDL锁，在**语句执行开始时申请**，但是语句结束后并**不会马上释放**，而会**等到整个事务提交后再释放**。

### MySQL行锁

MySQL的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表

### 行锁的加锁和释放时机：

在InnoDB事务中，行锁是**在需要的时候才加上**的，但并不是不需要了就立刻释放，而是要**等到事务结束**时才释放。这个就是**两阶段锁协议**。

### 增加并发的措施：

如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的**申请时机尽量往后放**。

### 死锁和死锁检测

行锁的使用和申请可能会导致死锁。

### 死锁的解决方法：

1.进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置；超时后锁会被释放。

2.发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

### 超时等待的时间需要平衡

不可能直接把这个时间设置成一个很小的值，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢。

### 主动死锁检测

费时：O(n)的时间复杂度。



### 如何避免死锁检测的巨大消耗：

1.直接关闭死锁检测，默认无死锁；

2.控制并发度，并发度降低则死锁检测的复杂度降低；

3.利用中间件实现；

4.修改mysql源码来解决：将相同行的更新在进入引擎之前进行排队；

5.将互斥资源分布开来，减小冲突的密集性。

<<<<<<< HEAD


### MySQL的备份

逻辑备份：逻辑备份是**备份sql语句**，在恢复的时候执行备份的sql语句实现数据库数据的重现。

物理备份：物理备份就是**备份数据文件**了，相当于cp下数据文件，但真正备份的时候自然不是的cp这么简单。

### 逻辑备份

逻辑备份：逻辑备份是**备份sql语句**，在恢复的时候执行备份的sql语句实现数据库数据的重现。

**mysqldump**是采用SQL级别的备份机制，他将数据表导成SQL脚本文件，是最常用的逻辑备份方法。

### 物理备份

物理备份：物理备份就是**备份数据文件**了，相当于cp下数据文件，但真正备份的时候自然不是的cp这么简单。

​	**1）使用 xtrabackup 工具**

是一个用来备份 MySQL数据库的开源工具。

主要特点：

<1>. 在线热备份。可以备份innodb和myisam。innodb主要应用recovery原理。myisam直接拷贝文件。

<2>. 支持流备份。可以备份到disk，tape和reomot host。–stream=tar ./ | ssh user@remotehost cat “>” /backup/dir/

<3>. 支持增量备份。可以利用lsn和基础备份目录来进行增量备份。

<4>. 支持记录slave上的master log和master position信息。

<5>. 支持多个进程同时热备份，xtrabackup的稳定性还是挺好的。

​	**2）LVM**

特点：热备、支持所有基于本地磁盘的存储引擎、快速备份、低开销、容易保持完整性、快速恢复等。

​	**3）cp + tar**

使用直接拷贝数据库文件的方式进行打包备份，需要注意的是执行步骤：锁表、备份、解表。

恢复也很简单，直接拷贝到之前的数据库文件的存放目录即可。

注意：对于Innodb引擎的表来说，还需要备份日志文件，即ib_logfile*文件。因为当Innodb表损坏时，就可以依靠这些日志文件来恢复。

​	**4）mysqlhotcopy**

mysqlhotcopy是一个perl程序，是lock tables、flush tables 和cp或scp来快速备份数据库。

它是备份数据库或单个表的最快的途径，但它只能运行在数据库文件（包括数据表文件、数据文件、索引文件）所在的机器上。

mysqlhotcopy只能用于备份MyISAM。

​	**5）使用mysql主从复制**

mysql的复制是指将主数据库的DDL和DML操作通过二进制文件（bin-log）传送到从服务器上，然后在从服务器上对这些日志做重新执行的操作，从而使得从服务器和主服务器保持数据的同步。