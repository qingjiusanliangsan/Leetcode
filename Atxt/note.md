
# MySQL笔记

### Mysql索引失效的情况：

1.全值匹配都会用到索引；

2.最佳左前缀法则：多列的联合索引，要遵守最左前缀法则，即查询从索引的最左前列开始并且不跳过索引中的列。**最佳左前缀法则：带头大哥不能死、中间兄弟不能断。**

​		从最左开始，建立的第一个索引不能丢失；

​		中间的字段不能断；

​		**范围列可以用到索引，但是范围列后面的列无法用到索引**：存储引擎不能**使用索引中范围条件右边的列**，即如果出现了范围查询，则此范围查询右边的索引会失效；

3.不能在索引字段上做任何操作，如计算、函数、sub、自动或手动的类型转换等；

4.尽量使用覆盖查询，减少使用select *;

5.使用不等于（!= 、<>）的时候会无法使用索引，导致全局扫描；

6.is null, is not null也无法使用索引；复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。

7.like的模糊查询以%开头会导致索引失效；

8.字符串不加单引号会使索引失效；

9.用or进行连接会使索引失效；

10.如果mysql估计使用全表扫描要比使用索引快,则不使用索引。

### mysql 查询优化器

当按照索引中所有列进行精确匹配**（“=” 或 “IN”）**时，索引可以被用到，并且 type 为 const。理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，**所以 MySQL 不存在 where 子句的顺序问题而造成索引失效。**



### 查询中不能使用索引的情况：

查询中的列**不是独立**的，“独立的列”是说索引列不能事表达式的一部分，也不能是函数的参数。

### 索引的选择性：

索引的数量和数据表总数的比值，最大为1，越大代表索引越好。

### 索引列长度过长时：

1.可以使用模拟哈希索引;

2.使用前缀索引，即以此列的前缀字符串作为索引，但是此时希望前缀索引的选择性越大越好。

3.前缀的长度和索引的选择性之间要有一个平衡，既不能太长又要有选择性。

### 前缀索引：

优点:索引更小、更快；

缺点：mysql无法使用前缀索引坐order by和group by；

### 后缀索引：

后缀索引也同样有用途，比如用来给电子邮件地址建后缀索引；

虽然Mysql不支持后缀索引，但可以对字符串反转之后建前缀索引来达到建立后缀索引的目标。

### 索引合并：

1.当出现多个单独索引做相交操作（AND）时，最好为这些索引做一个多列索引；

2.当出现多个单独索引做联合操作（OR）时，会浪费大量的CPU和内存资源；

3.优化器不会把这些资源计算在查询成本中，优化器只关心随机页面的读取。

### 索引的顺序：

1.多列索引的顺序从左到右排序，先按照左边第一列排序与，然后按照依次往右的列排序。

### 索引顺序的排列：

1.不用考虑排序和分组时，将**选择性**最高的列放到最左边。

2.但是场景不同，选择也不尽相同,有时候需要考虑最常用到的查询语句来进行优化。

3.平均情况的性能也能代表特殊情况下的性能，特殊情况可能回摧毁整个应用的性能。

### 聚簇索引：

1.**聚簇索引**时一种数据存储方式，并不是一个单独的索引类型，通常代表索引和数据行放在一块存储的索引方式。

2.因为无法同时把数据行和索引放在不同的地方，所以一个表只能右一个聚簇索引；

3.可以使用覆盖索引模拟多个聚簇索引的情况。

4.索引是由存储引擎负责实现的。

### 聚集索引的选择：

1.有些数据库服务器支持选择作为聚簇索引的列，但是Mysql暂时不支持。

### InnoDB的聚簇索引构建：

1.InnoDB引擎通过主键聚集数据；

2.若没有主键，则选取一个**唯一的非空索引**代替；

3.若没有唯一的非空索引，则**隐私定义一个主键**来作为聚簇索引。



### 聚簇索引的优缺点：

#### 优点：

1.相关数据保存在一起，存储密集，访问磁盘的数量变小，可以减少IO消耗；

2.数据访问更快，索引和数据在一块；

3.使用覆盖索引可以直接使用叶结点中的主键值。

#### 缺点：

1.非主键的插入会变慢；

2.每一次更新都可能导致移动数据；

3.会导致也分裂；

4.导致全表扫描变慢；

5.二级索引变大；二级索引需要两次查询，第一次查询到主键索引，第二次根据主键索引来进行查询实际的数据。

### 二级索引

1.二级索引的叶子结点的数据时行指针，保存的是指向主键指针的位置，而不是行的物理位置。

2.二级索引查找：首先根据二级索引的叶子节点找到对应的主键值；根据主键值查找对应的行。



### InnoDB的聚簇索引：

1.每一个叶子节点都包括了**主键值**、**事务ID**、用于事务的**MVCC**和**回滚指针**以及**其他的剩余列**。

2.InnoDB的二级索引存储的是主键值，而不是行指针，这样数据更新时，二级索引不需要改变，只需一级索引改变。虽然主键值占用空间更大，但是好处也很大，减少了更多的操作。

![image-20220330160023070](C:/Users/yyl/AppData/Roaming/Typora/typora-user-images/image-20220330160023070.png)



### 覆盖索引

1.如果一个索引包含所有需要查询的字段的值，我们就称整个索引为**覆盖索引**。

2.覆盖索引只需要扫描，不需要回表，速度很快；

3.覆盖索引必须要存储索引列的值。



### Mysql的覆盖索引

1.mysql不能在索引中执行Like操作。

2.MySQL能在索引中做最左前缀匹配的LIke查询。



### MySQL使用索引对结果做排序

1.只有当列顺序和ORDER BY字句的顺序完全一致，并且所有列的排序方向（正序和倒序）都一样时，MySQL才可以使用索引来对结果做排序。

2.若查询关联了多张表，只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。

3.使用索引做排序的一个最重要的用法是当**查询同时有ORDER BY和LIMIT子句**的时候。



### MyISAM压缩（前缀压缩）索引

1.以第一个值为基准，将其他值和第一个比较。如“perform performance”  -> "7 7,ance"

2.空间变小，速度变慢；



### 冗余和重复索引

1.MySQL的每个索引都要单独维护；

重复索引：A，A

冗余索引：（A，B）,A



### InnoDB的索引和锁：

1.InnoDB在二级索引上使用共享锁，但是访问主键索引需要排他锁。

2.这个方式消除了使用覆盖索引的可能性；并且使得select for update 比 lock in share mode慢很多。

3.尽可能的将需要做范围查询的列放到索引的后面，以便优化器能使用尽可能多的索引列。





