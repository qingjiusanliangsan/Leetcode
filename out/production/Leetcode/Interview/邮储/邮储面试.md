### 邮储面试

自我介绍：

我叫韩路通，现在就读于中科院信息工程研究所信息安全国家重点实验室，我的研究方向是计算机视觉；我本科毕业于西安电子科技大学，专业是软件工程。

在本科阶段，我获得了如国家励志奖学金、校优秀学生以及优秀毕业生等荣誉，并获得了研究生保送资格；我还通过了中级软件设计师资格考试。

在研究生阶段，我在科研方面以第二作者身份发表了两篇英文论文，级别分别是CCF-A和CCF-C；在项目方面，我分别完成了作为课设的**用于列车售票的可线性化并发数据结构项目**，以及用于**学习实践的基于Java实现的RPC框架项目**。





可线性化就是能够确定一个函数调用的可线性化点，然后过了这个可线性化点程序就可以认为是执行成功了，我这边是通过加锁实现的可线性化。 

可线性化：可线性化分析，由于对同一车次同一区间的购买、查询、退票均需要取得锁之后才能操作，所以这样保证了三个方法均具满足可线性化，可线性化点在相应的锁释放的时候，也就是离开临界区的时候，而不同车次的方法之间不会互相影响。

一个常见的表述是“提供每个操作在其调用和响应之间即时生效的错觉”。线性化的公式是由于Herlihy，它强调这是一个局部属性，而不是其他类型的顺序一致性属性，如全局的“可序列化”。

![image-20220413140800646](https://raw.githubusercontent.com/qingjiusanliangsan/typora/main/img/20220413140800.png)

RPC:

1.服务消费端(client)以本地调用的方式调用远程服务;
2.客户端 Stub(client stub)接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体(序列
化):RpcRequest:
3.客户端 Stub(client stub)找到远程服务的地址，并将消息发送到服务提供端

4.服务端 Stub(桩)收到消息将消息反序列化为Java对象:RpcRequest;
5.服务端 Stub(桩)根据 RpcRequest 中的类、方法、方法参数等信息调用本地的方法:
6.服务端 Stub(桩)得到方法执行结果并将组装成能够进行网络传输的消息体:RpcResponse (序列化)发 
送至消费方;

7.客户端Stub(client stub)接收到消息并将消息反序列化为Java对象:RpcResponse ，这样也就得到了最
终结果。over!



### 线程安全：

当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。

如果一段代码可以保证多个线程访问的时候正确操作共享数据，那么它是线程安全的。



1、建立通信

首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。

主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。

通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。

2、服务寻址

要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。

通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。

可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用Redis或者Zookeeper来注册服务等等。

2.1、从服务提供者的角度看：

当服务提供者启动的时候，需要将自己提供的服务注册到指定的注册中心，以便服务消费者能够通过服务注册中心进行查找；

当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；

服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果一段时间未收到来自服务提供者的心跳后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉。

2.2、从调用者的角度看：

服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；

当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；

服务调用者下线的时候，则取消订阅。

3、网络传输

3.1、序列化

当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。

3.2、反序列化

当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用,
通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。

4、服务调用

B机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理，一般是业务逻辑处理操作。



CCF-A:Identity-Preserving Face Anonymization via Adaptively Facial Attributes Obfuscation

随着计算机视觉技术在监控系统中的应用越来越普遍，由于监控系统所拍摄的图像或者视频中可能包含如人脸等与身份相关的信息，大家越来越关注监控系统所带来的个人隐私侵犯问题。现有保护此类隐私的方法主要侧重于从人脸图像中去除与身份相关的信息，但是这样会削弱当前监控系统的有效性。在本文中，我们开发了一个人脸匿名化框架，**该框架在混淆视觉外观的同时能够保持身份的可辨别性**。

此框架由两部分组成：身份感知区域发现模块和身份感知的人脸混淆模块。前者自适应地定位人脸中与身份信息无关的属性，后者**利用原始人脸和发现的身份信息无关属性生成隐私保护人脸**。为了优化人脸生成器，我们采用了基于多任务的损失函数，它由鉴别器损失函数、身份保留损失函数和重建损失函数组成。我们的模型可以通过根据实际需求设置需要修改的面部属性数量来实现识别效用和人脸匿名之间的平衡，并提供不同设置下的结果。我们在两个公共基准 Celeb-A 和 VGG-Face2 数据集上进行的大量实验，证明了我们模型在不同人脸识别场景下的有效性。



CCF-C:Learning Disentangled Representations for Identity Preserving Surveillance Face Camouflage

摘要：在本文中，我们专注于在监控场景下保护人们的面部隐私，**通过改变面部的一些视觉外观**，**同时保持它们被当前的面部识别系统识别**。这是一个具有挑战性的问题，因为我们需要保留捕获的面部图像中最重要的结构，同时修改显着的面部区域以保护个人隐私。为了解决这个问题，我们引入了一种新颖的个人面部保护模型，它可以伪装面部从人类视觉感知的角度来看外观，并保留用于人脸认证的人脸的身份特征。为此，我们开发了一种**编码器-解码器网络架构**，可以将面部特征表示分离为**外观代码和识别代码**。具体来说，我们首先将输入的人脸图像随机分成两组，源集和目标集，其中身份和外观代码可以对应提取。然后，我们重新组合身份和外观代码来合成一张新的人脸，它具有相同的身份作为源主体。最后，使用合成的人脸替换原始人脸，保护个人隐私。注意，我们的模型是端到端的，具有多任务损失函数，可以更好地保留身份并稳定训练过程。进行的实验在跨年龄名人数据集上展示了我们模型的有效性，并验证了我们在视觉质量和可扩展性方面的优势。

